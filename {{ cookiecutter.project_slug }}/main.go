package main

import (
	"bytes"
	"flag"
	"fmt"
	"log"
	"os"
	"path/filepath"
	"strings"

	"golang.org/x/tools/go/packages"
)

var (
	output  = flag.String("output", "", "output file name; default srcdir/{{ cookiecutter.project_slug }}.go")
	version = flag.Bool("version", false, "print version")
)

const usage = `{{ cookiecutter.project_slug }} - {{ cookiecutter.project_description }}

Usage:

  {{ cookiecutter.project_slug }} [flags]

Flags:`

func Usage() {
	fmt.Fprintln(os.Stderr, usage)
	flag.PrintDefaults()
}

func PrintLdflags() {
	fmt.Fprintln(os.Stderr, Ldflags())
}

func main() {
	log.SetFlags(0)
	log.SetPrefix("{{ cookiecutter.project_slug }}: ")
	flag.Usage = Usage
	flag.Parse()

	if *version {
		PrintLdflags()
		return
	}

	g := NewGenerator()
	g.parsePackage(flag.Args())

	g.printf("// Code generated by \"{{ cookiecutter.project_slug }} %s\"; DO NOT EDIT.\n\n", strings.Join(os.Args[1:], " "))
	g.printf("package %s\n\n", g.pkgName)

	if err := g.Generate(); err != nil {
		log.Panicf("during generation %v", err)
	}
	if err := writeResult(g.Bytes()); err != nil {
		log.Panicf("write file %v", err)
	}
}

func isDirectory(p string) bool {
	x, err := os.Stat(p)
	if err != nil {
		log.Fatal(err)
	}
	return x.IsDir()
}

func writeResult(src []byte) error { return os.WriteFile(destFilename(), src, 0600) }

func destFilename() string {
	if *output != "" {
		return *output
	}
	return filepath.Join(destDir(), "{{ cookiecutter.project_slug }}.go")
}

// Decide the directory to install the generated code based on positional arguments.
func destDir() string {
	args := flag.Args()
	if len(args) == 0 {
		args = []string{"."}
	}
	if len(args) == 1 && isDirectory(args[0]) {
		return args[0]
	}
	return filepath.Dir(args[0])
}

type Generator struct {
	buf     bytes.Buffer // generated code
	pkgName string
}

func NewGenerator() *Generator {
	return &Generator{}
}

func (g *Generator) printf(format string, v ...any) { fmt.Fprintf(&g.buf, format, v...) }
func (g *Generator) Bytes() []byte                  { return g.buf.Bytes() }

func (g *Generator) parsePackage(patterns []string) {
	pkgs, err := packages.Load(&packages.Config{
		Mode: packages.NeedName,
	}, patterns...)
	if err != nil {
		log.Fatal(err)
	}
	if len(pkgs) != 1 {
		log.Fatalf("%d packages found", len(pkgs))
	}
	g.pkgName = pkgs[0].Name
}

// Generate codes and write them into buf.
func (g *Generator) Generate() error {
	g.printf("func Generated() {}")
	return nil
}
